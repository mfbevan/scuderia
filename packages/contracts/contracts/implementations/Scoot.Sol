// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "../interfaces/IScoot.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract Scoot is IScoot, ERC20, AccessControl {
    bytes32 public constant GRANTER_ROLE = keccak256("GRANTER_ROLE");
    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");

    uint256 constant DAILY_REWARD = 10 ether;

    // tokenid => time tokens were last claimed to pending amount (i.e on transfer)
    mapping(address => uint256) lastClaimedTime;
    // Pending reward to be claimed (not including accumulated)
    mapping(address => uint256) pendingReward;

    constructor(address _admin) ERC20("Scoot", "SCT") {
        _setupRole(DEFAULT_ADMIN_ROLE, _admin);
    }

    function grantToken(address _recipient, uint256 _amount) external {
        if (!hasRole(GRANTER_ROLE, msg.sender)) revert InvalidRoleForAction();
        _mint(_recipient, _amount);
    }

    function burnToken(address _recipient, uint256 _amount) external {
        if (!hasRole(BURNER_ROLE, msg.sender)) revert InvalidRoleForAction();
        _burn(_recipient, _amount);
    }

    function claimToken() external {
        // uint256 claimable = unclaimedBalanceOf(msg.sender);
        // if (claimable == 0) revert ClaimingZeroReward();
        // _mint(msg.sender, claimable);
    }

    function unclaimedBalanceOf(address _account)
        external
        view
        returns (uint256)
    {
        return calculateAccumulatedReward(_account) + pendingReward[_account];
    }

    function calculateAccumulatedReward(address _account)
        internal
        view
        returns (uint256)
    {
        return 100;
    }

    function updateReward(address _sender, address _receiver) external {
        // ...
    }

}
