// SPDX-License-Identifier: MIT
pragma solidity 0.8.16;

import "../interfaces/IScuderia.sol";
import "./ERC721Stakable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Base64.sol";

import "erc721a/contracts/ERC721A.sol";

contract Scuderia is IScuderia, Ownable, ERC721Stakable {
    uint256 constant MAX_SUPPLY_GENESIS = 5000;
    uint256 constant MAX_SUPPLY_SECONDARY = 10000;
    uint64 MINT_PRICE = 0.1 ether;
    uint8 genesisSupply = 0;
    uint8 secondarySupply = 0;

    string private tokenBaseURI;
    string private contractURI;

    // tokenId => metadataSeed (randomised on mint)
    mapping(uint256 => uint256) metadataSeed;

    bool public saleActive = false;

    constructor(address _ownerAddress) ERC721Stakable("Scuderia", "SCD") {
        require(_ownerAddress != address(0), "owner address cannot be 0x0");
        if (_ownerAddress != msg.sender) {
            transferOwnership(_ownerAddress);
        }
    }

    function mint(uint256 _quantity) external payable {
        if (!saleActive) revert SaleInactive();
        if (_quantity == 0) revert ZeroQuantity();
        if (genesisSupply + _quantity > MAX_SUPPLY_GENESIS)
            revert SupplyWillBeExceeded();
        if (msg.value != MINT_PRICE * _quantity)
            revert IncorrectPaymentAmount();
        genesisSupply++;
        _safeMint(msg.sender, _quantity);
    }

    function secondaryMint(uint256 _blueprintId) external {
        // ...
    }

    /**
     * @notice Build the metadata URI for supplied token
     * @param tokenId the tokenId of the nft to generate metadata for
     */
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        uint256 seed = 10000;
        return _buildMetadata(seed);
    }

    function _buildMetadata(uint256 seed)
        internal
        view
        returns (string memory)
    {
        bytes memory image = abi.encodePacked(
            "data:image/svg+xml;base64,",
            Base64.encode(
                bytes(
                    abi.encodePacked(
                        '<?xml version="1.0" encoding="UTF-8"?>',
                        '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet">',
                        '<style type="text/css"><![CDATA[text { font-family: monospace; font-size: 21px;} .h1 {font-size: 40px; font-weight: 600;}]]></style>',
                        '<rect width="400" height="400" fill="#ffcfcf" />',
                        '<text class="h1" x="50" y="70">Scuderia NFT</text>',
                        unicode'<text x="100" y="240" style="font-size:100px;">üèéÔ∏èüí®</text>',
                        '<text x="20" y="350" style="font-size:28px;"> ',
                        "</text>",
                        '<text x="20" y="380" style="font-size:14px;">0x',
                        "</text>",
                        "</svg>"
                    )
                )
            )
        );

        return
            string(
                abi.encodePacked(
                    "data:application/json;base64,",
                    Base64.encode(
                        bytes(
                            abi.encodePacked(
                                '{"name":"Scuderia NFT", "image":"',
                                image,
                                unicode'", "description": "Scuderia is a fully on-chain racing NFT ecosystem that allows minting, metadata and image generation, racing and betting, all running on Polygon."}'
                            )
                        )
                    )
                )
            );
    }

    /**
     * @notice Sets the initial token id to start at 1 instead of 0
     */
    function _startTokenId() internal pure override returns (uint256) {
        return 1;
    }

    function walletOf(address _walletOwner)
        external
        view
        returns (uint256[] memory result)
    {
        uint256 tokenCount = balanceOf(_walletOwner);
        if (tokenCount == 0) {
            return new uint256[](0);
        } else {
            result = new uint256[](tokenCount);
            uint256 index = 0;

            for (uint256 tokenId = 1; tokenId <= _totalMinted(); tokenId++) {
                if (index == tokenCount) break;

                if (ownerOf(tokenId) == _walletOwner) {
                    result[index] = tokenId;
                    index++;
                }
            }
        }
    }

    /**
     * @notice Toggle whether nft minting is active
     */
    function toggleSale() external onlyOwner {
        saleActive = !saleActive;
    }

    /**
     * @notice Transfer funds out of contract
     * @param _recipient Receiver of funds
     */
    function withdraw(address _recipient) public onlyOwner {
        payable(_recipient).transfer(address(this).balance);
    }
}
